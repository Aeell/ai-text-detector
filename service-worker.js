const CACHE_NAME="ai-detector-cache-v1",APP_PREFIX="/ai-text-detector",RUNTIME_CACHE="ai-detector-runtime",PRECACHE_ASSETS=["/","/index.html","/css/main.css","/css/dark-theme.css","/css/responsive.css","/images/sherlock-ai-background.jpg","/favicon.ico"];function normalizeUrl(e){const t=self.location.origin;return e.startsWith("http")?e:`${t}${APP_PREFIX}${e}`}async function processOfflineAnalyses(){try{const e=await openDB(),t=await e.getAll("pending");for(const s of t)try{const t=await processAnalysis(s);await e.put("results",t),await e.delete("pending",s.id);(await self.clients.matchAll()).forEach((e=>{e.postMessage({type:"analysis-complete",result:t})}))}catch(e){console.error("Error processing offline analysis:",e)}}catch(e){console.error("Error handling offline analyses:",e)}}function openDB(){return new Promise(((e,t)=>{const s=indexedDB.open("AIDetectorDB",1);s.onerror=()=>t(s.error),s.onsuccess=()=>e(s.result),s.onupgradeneeded=e=>{const t=e.target.result;t.objectStoreNames.contains("pending")||t.createObjectStore("pending",{keyPath:"id"}),t.objectStoreNames.contains("results")||t.createObjectStore("results",{keyPath:"id"})}}))}async function processAnalysis(e){return{id:e.id,text:e.text,result:"Processed offline",timestamp:Date.now()}}self.addEventListener("install",(e=>{e.waitUntil(caches.open(CACHE_NAME).then((e=>{console.log("Caching app assets");const t=PRECACHE_ASSETS.map((e=>normalizeUrl(e)));return e.addAll(t)})).catch((e=>{console.error("Error caching assets:",e)}))),self.skipWaiting()})),self.addEventListener("activate",(e=>{e.waitUntil(Promise.all([caches.keys().then((e=>Promise.all(e.filter((e=>e.startsWith("ai-detector-")&&e!==CACHE_NAME&&e!==RUNTIME_CACHE)).map((e=>(console.log("Deleting old cache:",e),caches.delete(e))))))),self.clients.claim()]))})),self.addEventListener("fetch",(e=>{"GET"===e.request.method&&(e.request.url.startsWith("chrome-extension://")||(e.request.url.includes("/api/")?e.respondWith(fetch(e.request).catch((()=>caches.match(e.request)))):e.respondWith(fetch(e.request).then((t=>{if(t.ok){const s=t.clone();caches.open(RUNTIME_CACHE).then((t=>{t.put(e.request,s)}))}return t})).catch((()=>caches.match(e.request).then((t=>t||("navigate"===e.request.mode?caches.match(normalizeUrl("/index.html")):new Response("Network error happened",{status:408,headers:{"Content-Type":"text/plain"}})))))))))})),self.addEventListener("error",(e=>{console.error("Service Worker error:",e.error)})),self.addEventListener("unhandledrejection",(e=>{console.error("Service Worker unhandled rejection:",e.reason)})),self.addEventListener("sync",(e=>{"analyze-text"===e.tag&&e.waitUntil(processOfflineAnalyses())}));